"""Functions called to generate the Jupyter Notebook for GORi.

    2025/05/28 @yanisaspic"""


import nbformat
from typing import Any
from nbconvert.preprocessors import ExecutePreprocessor


def _get_notebook_template() -> str:
    """Get a Jupyter Notebook template for GORi.

    Returns
        A string with the Jupyter Notebook template.
        The placeholder `PLACEHOLDER_HERE` should be replaced with a path to GORi spreadsheets.
    """
    return """ {
 "cells": [
  {
   "cell_type": "markdown",
   "id": "c1ea0c03",
   "metadata": {},
   "source": [
    "# GORi: PLACEHOLDER_HERE"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "9b6746df",
   "metadata": {},
   "source": [
    "In this notebook, we use interactive tables and interactive plots (generated with `itables` and `plotly` respectively) to investigate the results of the GORi analysis. We start by loading and initializing the programmatic dependencies we need. We will also load the collection of spreadsheets generated by GORi."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "8c76f94f",
   "metadata": {
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "\n",
    "# import itables to interact with data tables\n",
    "from itables import init_notebook_mode\n",
    "from itables import show\n",
    "\n",
    "init_notebook_mode(all_interactive=True)\n",
    "\n",
    "# import Plotly to interact with plots\n",
    "import plotly.express as px"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "a4a9e871",
   "metadata": {},
   "outputs": [],
   "source": [
    "results = pd.read_excel(f\"PLACEHOLDER_HERE\", sheet_name=None)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "8e9e501f",
   "metadata": {},
   "source": [
    "## Results\n",
    "\n",
    "##### Gene annotations\n",
    "\n",
    "The boxplot and the table below report the number of annotations retrieved for each gene and prior.\n",
    "They include both direct and indirect annotations (*i.e.* annotations inferred from hierarchical relationships of a direct annotation)."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "0b81e48c",
   "metadata": {},
   "outputs": [],
   "source": [
    "# set-up the boxplot data\n",
    "boxplot_data = results[\"annotations\"].copy()\n",
    "boxplot_data = pd.melt(\n",
    "    boxplot_data, id_vars=\"gene\", var_name=\"prior\", value_name=\"# annotations\"\n",
    ")\n",
    "boxplot = px.box(\n",
    "    boxplot_data,\n",
    "    x=\"prior\",\n",
    "    y=\"# annotations\",\n",
    "    color=\"prior\",\n",
    "    points=\"all\",\n",
    "    hover_data=[\"gene\"],\n",
    "    color_discrete_sequence=px.colors.qualitative.Dark2,\n",
    ")\n",
    "\n",
    "boxplot.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "2f43b930",
   "metadata": {},
   "outputs": [],
   "source": [
    "# set-up the table of annotations\n",
    "annotations = results[\"annotations\"].copy()\n",
    "urls = [\n",
    "    f\"https://pubchem.ncbi.nlm.nih.gov/gene/{g}/Homo_sapiens\" for g in annotations.gene\n",
    "]\n",
    "annotations.gene = [\n",
    "    '<a href=\"{}\" target=\"_blank\">{}</a>'.format(u, g)\n",
    "    for u, g in zip(urls, annotations.gene)\n",
    "]\n",
    "\n",
    "# data table\n",
    "show(\n",
    "    annotations,\n",
    "    classes=\"display nowrap cell-border compact\",\n",
    "    columnDefs=[{\"className\": \"dt-center\", \"targets\": \"_all\"}],\n",
    "    style=\"table-layout:auto;width:100%;margin:auto\",\n",
    ")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "fb7e5c26",
   "metadata": {},
   "source": [
    "##### Pairwise associations \n",
    "\n",
    "The barplot and the table below report the number of association identified with each prior. These associations are sequentially reduced during the GORi analysis:\n",
    "\n",
    "- **target:** target associations are associations between two priors; namely, the genesets you are trying to annotate, and a specific knowledge base.\n",
    "- **strong:** strong associations are target associations with strong lift values or weak p-values; they are likely associations according to statistics.\n",
    "- **unique:** unique associations are strong associations that are not redundant with other strong associations; their annotations are not hierarchically connected.\n",
    "- **corrected:** corrected associations are unique associations with a significant p-value after applying the Benjamini-Hochberg correction.\n",
    "\n",
    "Please note that the y-axis of the barplot is log10-scaled."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "2f9f2410",
   "metadata": {},
   "outputs": [],
   "source": [
    "# set-up the barplot data\n",
    "barplot_data = results[\"counter\"].copy()\n",
    "barplot_data = pd.melt(\n",
    "    barplot_data,\n",
    "    id_vars=\"prior\",\n",
    "    var_name=\"type of association\",\n",
    "    value_name=\"# associations\",\n",
    ")\n",
    "barplot = px.bar(\n",
    "    barplot_data,\n",
    "    x=\"type of association\",\n",
    "    y=\"# associations\",\n",
    "    color=\"prior\",\n",
    "    text_auto=True,\n",
    "    barmode=\"group\",\n",
    "    log_y=True,\n",
    "    color_discrete_sequence=px.colors.qualitative.Dark2,\n",
    ")\n",
    "\n",
    "barplot.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "bbc1628a",
   "metadata": {},
   "outputs": [],
   "source": [
    "# set-up the table of associations (overview)\n",
    "counter = results[\"counter\"].copy()\n",
    "total = counter.sum(axis=0)\n",
    "total[\"prior\"] = \"<b>ALL</b>\"\n",
    "counter = pd.concat([total.to_frame().T, counter], ignore_index=True)\n",
    "\n",
    "# data table\n",
    "show(\n",
    "    counter,\n",
    "    columns_filter=\"header\",\n",
    "    classes=\"display nowrap cell-border compact\",\n",
    "    columnDefs=[{\"className\": \"dt-left\", \"targets\": 0}],\n",
    "    style=\"table-layout:auto;width:100%;margin:auto\",\n",
    ")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "94eefd14",
   "metadata": {},
   "source": [
    "##### Words of associations\n",
    "\n",
    "The table below reports the most characteristic words of each group annotated. These words are ranked according to their importance in the associations mined. Each column is a group, and the rows are used as ranks, so that the first row includes the most characteristic word of each group."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "fec2d397",
   "metadata": {},
   "outputs": [],
   "source": [
    "# set-up the table of words\n",
    "scores = results[\"scores\"].copy()\n",
    "scores.index.name = \"word\"\n",
    "_tmp = {}   # type: dict[str, pd.Series]\n",
    "for group in scores.columns:\n",
    "    scores = scores.sort_values(by=[group, \"word\"], ascending=[False, True])\n",
    "    _tmp[group] = scores[group].loc[scores[group] > 0].index.tolist()\n",
    "top_words = pd.DataFrame(dict([(k, pd.Series(v)) for k, v in _tmp.items()]))\n",
    "\n",
    "# data table\n",
    "show(top_words)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "3fd83faf",
   "metadata": {},
   "source": [
    "### List of associations\n",
    "\n",
    "The table below reports the associations predicted by GORi. Each row represents an association, and there are seven columns:\n",
    "\n",
    "- **antecedents** and **consequents** are two terms associated together.\n",
    "- **lift** and **n_genes** are two metrics used to quantify the strength of an association.\n",
    "- **prior_A** and **prior_C** indicate the prior knowledge categories of the antecedents and conseuqents, respectively.\n",
    "- **genes** is a list of comma-separated genes that are annotated by an antecedent and a consequent simultaneously."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "35431a59",
   "metadata": {},
   "outputs": [],
   "source": [
    "# set-up the table of associations (in full)\n",
    "associations = results[\"associations\"].copy()\n",
    "associations.antecedents = [\n",
    "    a\n",
    "    if isinstance(a, float)\n",
    "    else '<a href=\"https://{}\" target=\"_blank\">{}</a>'.format(u, a)\n",
    "    for a, u in zip(associations.antecedents, associations.url_a)\n",
    "]\n",
    "associations.consequents = [\n",
    "    '<a href=\"https://{}\" target=\"_blank\">{}</a>'.format(u, c)\n",
    "    for c, u in zip(associations.consequents, associations.url_c)\n",
    "]\n",
    "\n",
    "# data table\n",
    "show(\n",
    "    associations[[\"antecedents\", \"consequents\", \"lift\", \",n_genes\", \"genes\", \"prior_a\", \"prior_c\"]],\n",
    "    layout={\"top1\": \"searchBuilder\"},\n",
    "    classes=\"display nowrap cell-border compact\",\n",
    "    columnDefs=[{\"className\": \"dt-left\", \"targets\": \"_all\"}],\n",
    "    rowGroup={\"dataSrc\": 0},\n",
    ")"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.12"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
    }"""


def _write_notebook(params: dict[str, Any]) -> None:
    """Execute a Jupyter Notebook for GORi.

    ``params`` is a dict of parameters.
    """
    template = _get_notebook_template()
    template = template.replace("PLACEHOLDER_HERE", params["sheets_path"])
    print(template)
    ep = ExecutePreprocessor(timeout=600, kernel_name="python3")
    nb_out = ep.preprocess(template)
    print(nb_out)
    with open(params["notebook_path"], "w", encoding="utf-8") as f:
        f.write(nb_out)
